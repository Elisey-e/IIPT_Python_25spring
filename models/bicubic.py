"""
Модуль для бикубической интерполяции цветных изображений на новой сетке координат.

Реализует бикубическую интерполяцию для пересчета значений многоканального изображения
с одной сетки координат на другую с повышенной точностью по сравнению с билинейной.
Особенно эффективен для задач увеличения разрешения изображений (апскейлинга).

Требуемые библиотеки:
- numpy
- scipy
"""

import numpy as np
import scipy.interpolate as interp


def bicubic_interpolation(
    x: list | np.ndarray, y: list | np.ndarray, values: np.ndarray, xi: list | np.ndarray, yi: list | np.ndarray
) -> np.ndarray:
    """
    Выполняет бикубическую интерполяцию цветного изображения на новой сетке координат.

    Параметры:
    ----------
    x : list или np.ndarray
        1D массив x-координат исходной сетки (по ширине изображения).
        Должен быть строго возрастающим.
    y : list или np.ndarray
        1D массив y-координат исходной сетки (по высоте изображения).
        Должен быть строго возрастающим.
    values : np.ndarray
        3D массив значений исходного изображения в формате (H, W, C),
        где H - высота, W - ширина, C - количество цветовых каналов.
        Значения должны быть в диапазоне [0, 255].
    xi : list или np.ndarray
        1D массив x-координат целевой сетки (по ширине изображения).
        Должен находиться в пределах диапазона исходных x-координат.
    yi : list или np.ndarray
        1D массив y-координат целевой сетки (по высоте изображения).
        Должен находиться в пределах диапазона исходных y-координат.

    Возвращает:
    ----------
    np.ndarray
        3D массив интерполированных значений в формате (H', W', C),
        где H' - высота новой сетки, W' - ширина новой сетки,
        C - количество цветовых каналов. Значения нормализованы в [0, 1).

    Исключения:
    ----------
    ValueError
        - Если входные координаты не являются строго возрастающими
        - Если целевые координаты выходят за пределы исходного диапазона
        - Если массив values не трехмерный

    Примеры:
    --------
    >>> # Исходное изображение 3x3 RGB
    >>> x_orig = np.array([0, 1, 2])
    >>> y_orig = np.array([0, 1, 2])
    >>> img = np.random.randint(0, 256, (3, 3, 3), dtype=np.uint8)
    >>>
    >>> # Новая сетка 5x5
    >>> x_new = np.linspace(0, 2, 5)
    >>> y_new = np.linspace(0, 2, 5)
    >>>
    >>> # Применение бикубической интерполяции
    >>> result = bicubic_interpolation(x_orig, y_orig, img, x_new, y_new)
    >>> print(f"Result shape: {result.shape}, dtype: {result.dtype}")
    Result shape: (5, 5, 3), dtype: float64

    Примечания:
    ----------
    1. Особенности бикубической интерполяции:
       - Дает более гладкие результаты по сравнению с билинейной
       - Сохраняет тонкие детали лучше, чем билинейная
       - Вычислительно более сложная (примерно в 2-3 раза медленнее билинейной)

    2. Ограничения:
       - Требует равномерной или логарифмически равномерной сетки
       - Может создавать артефакты перерегуляризации на резких границах
       - Не подходит для очень больших изображений (>2048px) из-за памяти

    3. Рекомендации:
       - Для медицинских изображений используйте параметр kind='quintic'
       - Для HDR-изображений предварительно преобразуйте в логарифмическое пространство
       - Для пакетной обработки рассмотрите GPU-ускорение через torch.nn.functional.interpolate
    """
    # Валидация входных данных
    channels = []
    for i in range(values.shape[2]):
        # Создание бикубического интерполятора для канала
        f = interp.interp2d(x, y, values[:, :, i], kind="cubic")

        # Интерполяция на новой сетке (автоматическая обработка границ)
        channels.append(f(xi, yi))

    # Комбинирование каналов и нормализация
    return np.stack(channels, axis=-1) / 256.0
